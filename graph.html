<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Results</title>
    <link rel="stylesheet" href="wts.css" />
    <link rel="icon" type="image/x-icon" href="./assests/logo/Logo_last.png" />
    <link rel="stylesheet" href="graph.css">
    <link rel="stylesheet" href="styles.css">
    <!-- Include Chart.js from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Include html2canvas and jsPDF libraries -->
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

  
  </head>

  <body>
    <header class="header">
      <img src="./assests/logo/Logo.png" alt="Logo" class="logo" />
      <img src="./assests/logo/header.png" alt="Header" class="header-image" />
    </header>
    <button class="download-button" id="downloadBtn">Download Report</button>
    <h3 id="classNameDisplay" style="color: white;"></h3>
    <div class="instructions-container">
      <h2>Instructions</h2>
      <ol>
        <li>1. Download the Report.</li>
        <br />
        <li>
          2. Upload it in your drive inside your homework folder
        </li>
      </ol>
    </div>

    <div class="marks-breakdown" id="breakdown">
      <h2>Assessment</h2>
      <h2>Score</h2>
      <ul id="marksList"></ul>
    </div>

    <div id="picdiv"></div>
    <div id="questiondiv"></div>
    <!-- Add this inside the <body> where appropriate -->
    <div id="pagination-controls" style="text-align: center; margin: 20px 0">
      <button id="prevPage" class="pagination-button">Previous</button>
      <span id="pageNumber">Page 1</span>
      <button id="nextPage" class="pagination-button">Next</button>
    </div>
   
    
    
    <button class="download-button" id="downloadBtn2">Download Report</button>

    <div class="loading-overlay" id="loadingOverlay">Downloading...</div>
    

    <script>
      const uniqueKey = "Sci_Asses_G9M2PSNZ";
      const className = "Sci_Asses_G9M2PSNZ";

      document.getElementById("classNameDisplay").textContent = className;

      // Helper function to get data from local storage under the unique key

      function getFromLocalStorage(key) {
        let storageData = JSON.parse(localStorage.getItem(key)) || {};
        return storageData;
      }

      // getFromLocalStorage(uniqueKey);

      // Variables to keep track of pagination
      let currentPage = 0;
      const questionsPerPage = 8; // Number of questions per page

      // Function to handle pagination and update the display
      function setupPagination() {
        const questionDiv = document.getElementById("questiondiv");
        const questions = Array.from(questionDiv.querySelectorAll("div"));

        // Remove old pages
        questionDiv.innerHTML = "";

        // Create pages
        for (let i = 0; i < questions.length; i += questionsPerPage) {
          const pageDiv = document.createElement("div");
          pageDiv.classList.add("question-page");
          for (
            let j = i;
            j < i + questionsPerPage && j < questions.length;
            j++
          ) {
            pageDiv.appendChild(questions[j]);
          }
          questionDiv.appendChild(pageDiv);
        }

        // Initialize the first page
        updatePagination();
      }

      // Function to update the pagination display
      function updatePagination() {
        const questionPages = document.querySelectorAll(".question-page");
        questionPages.forEach((page, index) => {
          page.style.display = index === currentPage ? "block" : "none";
        });

        // Update the page number display
        document.getElementById("pageNumber").textContent = `Page ${
          currentPage + 1
        } `;

        // Enable/disable buttons based on the current page
        document.getElementById("prevPage").disabled = currentPage === 0;
        document.getElementById("nextPage").disabled =
          currentPage === questionPages.length - 1;
      }

      // Event listeners for pagination buttons
      document.getElementById("prevPage").addEventListener("click", () => {
        if (currentPage > 0) {
          currentPage--;
          updatePagination();
        }
      });

      document.getElementById("nextPage").addEventListener("click", () => {
        const questionPages = document.querySelectorAll(".question-page");
        if (currentPage < questionPages.length - 1) {
          currentPage++;
          updatePagination();
        }
      });

      // Call setupPagination to initialize pagination when the page loads
      setupPagination();

      function clearLocalStorage() {
        console.log("Clearing local storage...");
        localStorage.removeItem(uniqueKey);

       
      }

      // Function to load and display all results with '_question_content'
      function loadAllResults() {
        console.log(uniqueKey, "test");

        // Clear existing content
        const questionContentDiv = document.getElementById("questiondiv");
        questionContentDiv.innerHTML = ""; // Clear content

        const picContentDiv = document.getElementById("picdiv");
        picContentDiv.style.display = "none"; // Hide picture content

        // Display content for the unique key
        displayContentForKey(uniqueKey);
      }
      
      // picContentDiv.display = none;

      // Function to display content based on the unique key
      function displayContentForKey(uniqueKey) {
        // Get the data associated with the uniqueKey
        const data = getFromLocalStorage(uniqueKey);
        console.log("data", data);

        // Ensure data is an object and contains _question_content
        if (data && typeof data === "object") {
          Object.keys(data).forEach((key) => {
            console.log("key", key);

            // Check if the key includes "_question_content"
            if (key.includes("_question_content")) {
              console.log("ok");
              const content = data[key];
              const topicName = key.replace("_question_content", ""); // Extract topic name

              // Create a container for each topic
              const topicContainer = document.createElement("div");
              topicContainer.style.marginBottom = "20px";
              topicContainer.style.padding = "10px";
              topicContainer.style.border = "1px solid #ddd";
              topicContainer.style.borderRadius = "8px";
              topicContainer.style.backgroundColor = "#fff";

              // Create and append the topic heading
              const heading = document.createElement("h3");
              heading.textContent = topicName;
              heading.style.marginTop = "0";
              heading.style.color = "#D6B65B";
              topicContainer.appendChild(heading);

              // Create and append the content
              const contentDiv = document.createElement("div");
              contentDiv.innerHTML = content;
              contentDiv.style.padding = "10px";
              topicContainer.appendChild(contentDiv);

              // Append the topic container to the questionContentDiv
              document
                .getElementById("questiondiv")
                .appendChild(topicContainer);
            }
          });
        } else {
          console.warn("No data available for the key:", uniqueKey);
        }
      }

      // Call this function to load and display results
      loadAllResults();

      // Fetch topics, scores, and total marks from localStorage
      const data2 = JSON.parse(localStorage.getItem(uniqueKey)) || {};
      const topics = data2.topics || [];
      console.log("topics", topics);

      /// Fetch scores and total marks using the unique key
      const scores = topics.map(
        (topic) => parseInt(data2[`${topic.heading}_score`]) || 0
      );
      const totalMarks = topics.map(
        (topic) => parseInt(data2[`${topic.heading}_totalQuestions`]) || 0
      );

      // Determine maximum total marks to scale the y-axis
      const maxTotalMarks = Math.max(...totalMarks);

      // Data for the chart
      const data = {
        labels: topics.map((topic) => topic.heading),
        datasets: [
          {
            label: "Marks Scored",
            data: scores,
            backgroundColor: "rgba(70, 192, 192, 0.6)",
            borderColor: "rgba(70, 192, 192, 1)",
            borderWidth: 1,
          },
        ],
      };

      // Configuration options for the chart
      const options = {
        scales: {
          y: {
            beginAtZero: true,
            suggestedMax: maxTotalMarks, // Set max value based on total questions
            title: {
              display: true,
              text: "Marks Scored",
            },
          },
        },
        plugins: {
          legend: {
            position: "top",
          },
          tooltip: {
            callbacks: {
              label: function (context) {
                return context.dataset.label + ": " + context.raw;
              },
            },
          },
        },
      };

      // Display the marks breakdown with question type details
      const marksList = document.getElementById("marksList");
      
      // Get MCQ score and calculate total MCQ marks
      const mcqScore = parseInt(data2[`${className}_mcq_score`]) || 0;
      
      // Calculate total marks for each section from the topics data
      let totalMCQMarks = 0;
      let totalShortQuestions = 0;
      let totalLongQuestions = 0;
      
      if (topics.length > 0 && topics[0].questions) {
        topics[0].questions.forEach(q => {
          const section = q.section || 'mcq';
          const marks = q.marks || (section === 'short' ? 3 : section === 'long' ? 5 : 1);
          
          if (section === 'mcq') {
            totalMCQMarks += marks;
          } else if (section === 'short') {
            totalShortQuestions++;
          } else if (section === 'long') {
            totalLongQuestions++;
          }
        });
      }
      
      // Create MCQ score item
      const mcqLi = document.createElement("li");
      mcqLi.innerHTML = `<strong>MCQ:</strong> <span>${mcqScore} / ${totalMCQMarks}</span>`;
      marksList.appendChild(mcqLi);
      
      // Create Short Questions item
      if (totalShortQuestions > 0) {
        const shortLi = document.createElement("li");
        shortLi.innerHTML = `<strong>Short Answer Questions (3 Marks each):</strong> <span>Analyzed by Teacher</span><br><small style="color: #888;">Total Questions: 8 (Attempt any 7)</small>`;
        marksList.appendChild(shortLi);
      }
      
      // Create Long Questions item
      if (totalLongQuestions > 0) {
        const longLi = document.createElement("li");
        longLi.innerHTML = `<strong>Long Answer Questions (5 Marks each):</strong> <span>Analyzed by Teacher</span><br><small style="color: #888;">Total Questions: ${totalLongQuestions} (Attempt any 3)</small>`;
        marksList.appendChild(longLi);
      }

      // Function to add watermark to PDF page
      function addWatermarkToPDF(pdf) {
        const pageWidth = pdf.internal.pageSize.getWidth();
        const pageHeight = pdf.internal.pageSize.getHeight();
        
        // Save the current graphics state
        pdf.saveGraphicsState();
        
        // Set watermark properties
        pdf.setGState(new pdf.GState({opacity: 0.15})); // Set opacity to 15%
        pdf.setTextColor(255, 165, 0); // Light orange color
        pdf.setFontSize(50); // Font size
        pdf.setFont(undefined, 'bold'); // Make it bold
        
        // Watermark position
        const centerX1 = pageWidth * 0.6;
        const centerY1 = pageHeight * 0.65;
        
        pdf.text("Way To Succeed", centerX1, centerY1, {
          angle: 45, // 45-degree angle
          align: 'center',
          baseline: 'middle'
        });
        
        // Restore the graphics state
        pdf.restoreGraphicsState();
      }

      // Function to add score data directly to PDF (without image capture)
      function addScoreDataToPDF(pdf, yPosition) {
        const data = JSON.parse(localStorage.getItem(uniqueKey)) || {};
        const topics = data.topics || [];
        
        // Calculate total marks for each section
        let totalMCQMarks = 0;
        let totalShortQuestions = 0;
        let totalLongQuestions = 0;
        
        if (topics.length > 0 && topics[0].questions) {
          topics[0].questions.forEach(q => {
            const section = q.section || 'mcq';
            const marks = q.marks || (section === 'short' ? 3 : section === 'long' ? 5 : 1);
            
            if (section === 'mcq') {
              totalMCQMarks += marks;
            } else if (section === 'short') {
              totalShortQuestions++;
            } else if (section === 'long') {
              totalLongQuestions++;
            }
          });
        }
        
        const mcqScore = parseInt(data[`${className}_mcq_score`]) || 0;
        
        // Calculate box height based on number of sections
        let numSections = 1; // MCQ always present
        if (totalShortQuestions > 0) numSections++;
        if (totalLongQuestions > 0) numSections++;
        
        const boxWidth = pdf.internal.pageSize.getWidth() - 20;
        const boxHeight = 15 + (numSections * 12);
        
        // Save graphics state to apply transparency
        pdf.saveGraphicsState();
        pdf.setGState(new pdf.GState({opacity: 0.6}));
        pdf.setFillColor(220, 220, 220);
        pdf.rect(10, yPosition - 5, boxWidth, boxHeight, 'F');
        pdf.restoreGraphicsState();
        
        // Draw border
        pdf.setDrawColor(180, 180, 180);
        pdf.setLineWidth(0.5);
        pdf.rect(10, yPosition - 5, boxWidth, boxHeight, 'S');
        
        let currentY = yPosition + 5;
        
        // Set font for the scores
        pdf.setFontSize(12);
        pdf.setFont(undefined, 'bold');
        pdf.setTextColor(0, 0, 0);

        pdf.text(`Assessment`, 15, currentY);
        currentY += 10;
        
        // MCQ Score
        pdf.text(`MCQ: ${mcqScore} / ${totalMCQMarks}`, 15, currentY);
        currentY += 10;
        
        // Short Questions
        if (totalShortQuestions > 0) {
          pdf.text(`Short Answer Questions (3 Marks each): Analyzed by Teacher`, 15, currentY);
          currentY += 10;
        }
        
        // Long Questions
        if (totalLongQuestions > 0) {
          pdf.text(`Long Answer Questions (5 Marks each): Analyzed by Teacher`, 15, currentY);
          currentY += 10;
        }
        
        return currentY + 10;
      }

      // Updated downloadReport function
      async function downloadReport() {
        const { jsPDF } = window.jspdf;

        // Show the loading overlay
        document.getElementById("loadingOverlay").style.display = "flex";

        // Create a new jsPDF instance
        const pdf = new jsPDF("p", "mm", "a4");

        // Function to load an image
        async function loadImage(src) {
          return new Promise((resolve) => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.src = src;
          });
        }

        // Add a short delay to ensure all elements are rendered
        await new Promise((resolve) => setTimeout(resolve, 500));

        // Load the logo and banner
        const logo = await loadImage("./assests/logo/Logo.png");
        const banner = await loadImage("./assests/logo/banner.png");
        const logoWidth = 30;
        const logoHeight = (logo.height * logoWidth) / logo.width;
        const bannerWidth = pdf.internal.pageSize.getWidth() - 20;
        const bannerHeight = (banner.height * bannerWidth) / banner.width;

        // Add watermark to the first page
        addWatermarkToPDF(pdf);

        // Add banner image
        pdf.addImage(banner.src, "PNG", 10, 10, bannerWidth, bannerHeight);
        
        // Add score data directly (not as image) below the banner
        const scoreYPosition = 10 + bannerHeight + 20; // 20mm margin below banner
        addScoreDataToPDF(pdf, scoreYPosition);

        // Function to add paginated content
        async function addPaginatedContent(contentDiv, pdf) {
          const contentPages = document.querySelectorAll(".question-page");
          let isFirstContentPage = true;

          for (let i = 0; i < contentPages.length; i++) {
            const page = contentPages[i];
            
            // Add a new page only after the first content page
            if (!isFirstContentPage) {
              pdf.addPage();
              addWatermarkToPDF(pdf);
            }
            
            // Ensure the page is visible before capturing it
            page.style.display = "block";

            // Capture the page as a canvas
            const pageCanvas = await html2canvas(page, { 
              scale: 1,
              backgroundColor: null,
              allowTaint: true,
              useCORS: true
            });
            const pageImage = pageCanvas.toDataURL("image/png", 0.7);
            
            const pageWidth = pdf.internal.pageSize.getWidth() - 20;
            const pageHeight = pdf.internal.pageSize.getHeight() - 20;
            const imgWidth = pageWidth;
            const imgHeight = (pageCanvas.height * imgWidth) / pageCanvas.width;

            // Add the page image to PDF
            pdf.addImage(pageImage, "PNG", 10, 10, imgWidth, Math.min(imgHeight, pageHeight));
            
            // Add the logo to the top right corner
            pdf.addImage(
              logo.src,
              "PNG",
              pdf.internal.pageSize.getWidth() - logoWidth - 10,
              10,
              logoWidth,
              logoHeight
            );

            // Hide the page after processing it
            page.style.display = "none";
            
            isFirstContentPage = false;
          }
        }

        // Add paginated content to the PDF - start on a new page
        pdf.addPage();
        addWatermarkToPDF(pdf);
        await addPaginatedContent(document.getElementById("questiondiv"), pdf);

        pdf.save(`${className}.pdf`);

        // Hide the loading overlay
        document.getElementById("loadingOverlay").style.display = "none";

        // Clear local storage
        clearLocalStorage();
        window.location.href = 'thankyou.html';
      }

      document
        .getElementById("downloadBtn")
        .addEventListener("click", downloadReport);
      document
        .getElementById("downloadBtn2")
        .addEventListener("click", downloadReport);

        function disableDevToolsSilently() {
    // 1️⃣ Disable right-click
    document.addEventListener("contextmenu", e => e.preventDefault());

    // 2️⃣ Disable common DevTools keyboard shortcuts
    document.addEventListener("keydown", function (e) {
      if (
        e.key === "F12" ||
        (e.ctrlKey && e.shiftKey && ["I", "J", "C"].includes(e.key)) ||
        (e.ctrlKey && e.key === "U")
      ) {
        e.preventDefault();
        e.stopPropagation();
        return false;
      }
    });

    // 3️⃣ Disable text selection & copy
    document.body.style.userSelect = "none";
    document.body.style.webkitUserSelect = "none";
    document.body.style.mozUserSelect = "none";

    // 4️⃣ Silent DevTools detection (no alert, no redirect)
    let devtoolsOpen = false;
    const threshold = 160;

    setInterval(() => {
      const widthDiff = window.outerWidth - window.innerWidth;
      const heightDiff = window.outerHeight - window.innerHeight;

      devtoolsOpen = widthDiff > threshold || heightDiff > threshold;

      if (devtoolsOpen) {
        // Silent sabotage
        console.clear();
        debugger;
      }
    }, 800);
  }

  // Call it
  disableDevToolsSilently();
    </script>
  </body>
</html>